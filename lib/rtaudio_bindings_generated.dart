// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/rtaudio.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class RtaudioBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RtaudioBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RtaudioBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int rta_get_device(
    int id,
    ffi.Pointer<rta_audio_device_t> info,
  ) {
    return _rta_get_device(
      id,
      info,
    );
  }

  late final _rta_get_devicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int, ffi.Pointer<rta_audio_device_t>)>>('rta_get_device');
  late final _rta_get_device = _rta_get_devicePtr
      .asFunction<int Function(int, ffi.Pointer<rta_audio_device_t>)>();

  int rta_get_device_count(
    ffi.Pointer<ffi.Int> count,
  ) {
    return _rta_get_device_count(
      count,
    );
  }

  late final _rta_get_device_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Int>)>>(
          'rta_get_device_count');
  late final _rta_get_device_count =
      _rta_get_device_countPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int rta_get_devices(
    ffi.Pointer<rta_audio_device_t> list,
  ) {
    return _rta_get_devices(
      list,
    );
  }

  late final _rta_get_devicesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<rta_audio_device_t>)>>(
      'rta_get_devices');
  late final _rta_get_devices = _rta_get_devicesPtr
      .asFunction<int Function(ffi.Pointer<rta_audio_device_t>)>();

  int rta_context_create(
    ffi.Pointer<rta_audio_context_config_t> contextConfig,
    ffi.Pointer<rta_audio_device_t> device,
    ffi.Pointer<rta_audio_context_t> context,
  ) {
    return _rta_context_create(
      contextConfig,
      device,
      context,
    );
  }

  late final _rta_context_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<rta_audio_context_config_t>,
              ffi.Pointer<rta_audio_device_t>,
              ffi.Pointer<rta_audio_context_t>)>>('rta_context_create');
  late final _rta_context_create = _rta_context_createPtr.asFunction<
      int Function(ffi.Pointer<rta_audio_context_config_t>,
          ffi.Pointer<rta_audio_device_t>, ffi.Pointer<rta_audio_context_t>)>();

  int rta_context_create_aaudio(
    ffi.Pointer<rta_audio_context_config_t> contextConfig,
    int deviceID,
    ffi.Pointer<rta_audio_context_t> context,
  ) {
    return _rta_context_create_aaudio(
      contextConfig,
      deviceID,
      context,
    );
  }

  late final _rta_context_create_aaudioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<rta_audio_context_config_t>, ffi.Int,
              ffi.Pointer<rta_audio_context_t>)>>('rta_context_create_aaudio');
  late final _rta_context_create_aaudio =
      _rta_context_create_aaudioPtr.asFunction<
          int Function(ffi.Pointer<rta_audio_context_config_t>, int,
              ffi.Pointer<rta_audio_context_t>)>();

  void rta_context_destroy(
    ffi.Pointer<rta_audio_context_t> context,
  ) {
    return _rta_context_destroy(
      context,
    );
  }

  late final _rta_context_destroyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<rta_audio_context_t>)>>(
      'rta_context_destroy');
  late final _rta_context_destroy = _rta_context_destroyPtr
      .asFunction<void Function(ffi.Pointer<rta_audio_context_t>)>();

  /// global context
  late final ffi.Pointer<ma_context> _g_Context =
      _lookup<ma_context>('g_Context');

  ma_context get g_Context => _g_Context.ref;

  late final ffi.Pointer<ffi.Int> _g_ContextInitialized =
      _lookup<ffi.Int>('g_ContextInitialized');

  int get g_ContextInitialized => _g_ContextInitialized.value;

  set g_ContextInitialized(int value) => _g_ContextInitialized.value = value;
}

abstract class rta_error {
  static const int RTA_SUCCESS = 0;
  static const int RTA_ERROR = 1;
  static const int RTA_FAILED_TO_INITIALIZE_CONTEXT = 2;
  static const int RTA_FAILED_TO_GET_DEVICES = 3;
  static const int RTA_FAILED_TO_INIT_DEVICE = 4;
  static const int RTA_INVALID = 5;
}

/// MINIAUDIO datasource
final class rta_audio_callback_datasource_t extends ffi.Struct {
  external ma_data_source_base base;

  external rta_audio_callback_t dataCallback;

  @ma_uint32()
  external int numChannels;

  @ma_uint32()
  external int sampleRate;
}

final class ma_data_source_base extends ffi.Struct {
  external ffi.Pointer<ma_data_source_vtable> vtable;

  @ma_uint64()
  external int rangeBegInFrames;

  /// Set to -1 for unranged (default).
  @ma_uint64()
  external int rangeEndInFrames;

  /// Relative to rangeBegInFrames.
  @ma_uint64()
  external int loopBegInFrames;

  /// Relative to rangeBegInFrames. Set to -1 for the end of the range.
  @ma_uint64()
  external int loopEndInFrames;

  /// When non-NULL, the data source being initialized will act as a proxy and will route all operations to pCurrent. Used in conjunction with pNext/onGetNext for seamless chaining.
  external ffi.Pointer<ma_data_source> pCurrent;

  /// When set to NULL, onGetNext will be used.
  external ffi.Pointer<ma_data_source> pNext;

  /// Will be used when pNext is NULL. If both are NULL, no next will be used.
  external ma_data_source_get_next_proc onGetNext;

  @ma_bool32()
  external int isLooping;
}

final class ma_data_source_vtable extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ma_data_source> pDataSource,
              ffi.Pointer<ffi.Void> pFramesOut,
              ma_uint64 frameCount,
              ffi.Pointer<ma_uint64> pFramesRead)>> onRead;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ma_data_source> pDataSource,
              ma_uint64 frameIndex)>> onSeek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ma_data_source> pDataSource,
              ffi.Pointer<ffi.Int32> pFormat,
              ffi.Pointer<ma_uint32> pChannels,
              ffi.Pointer<ma_uint32> pSampleRate,
              ffi.Pointer<ma_channel> pChannelMap,
              ffi.Size channelMapCap)>> onGetDataFormat;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ma_data_source> pDataSource,
              ffi.Pointer<ma_uint64> pCursor)>> onGetCursor;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ma_data_source> pDataSource,
              ffi.Pointer<ma_uint64> pLength)>> onGetLength;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ma_data_source> pDataSource,
              ma_bool32 isLooping)>> onSetLooping;

  @ma_uint32()
  external int flags;
}

abstract class ma_result {
  static const int MA_SUCCESS = 0;

  /// A generic error.
  static const int MA_ERROR = -1;
  static const int MA_INVALID_ARGS = -2;
  static const int MA_INVALID_OPERATION = -3;
  static const int MA_OUT_OF_MEMORY = -4;
  static const int MA_OUT_OF_RANGE = -5;
  static const int MA_ACCESS_DENIED = -6;
  static const int MA_DOES_NOT_EXIST = -7;
  static const int MA_ALREADY_EXISTS = -8;
  static const int MA_TOO_MANY_OPEN_FILES = -9;
  static const int MA_INVALID_FILE = -10;
  static const int MA_TOO_BIG = -11;
  static const int MA_PATH_TOO_LONG = -12;
  static const int MA_NAME_TOO_LONG = -13;
  static const int MA_NOT_DIRECTORY = -14;
  static const int MA_IS_DIRECTORY = -15;
  static const int MA_DIRECTORY_NOT_EMPTY = -16;
  static const int MA_AT_END = -17;
  static const int MA_NO_SPACE = -18;
  static const int MA_BUSY = -19;
  static const int MA_IO_ERROR = -20;
  static const int MA_INTERRUPT = -21;
  static const int MA_UNAVAILABLE = -22;
  static const int MA_ALREADY_IN_USE = -23;
  static const int MA_BAD_ADDRESS = -24;
  static const int MA_BAD_SEEK = -25;
  static const int MA_BAD_PIPE = -26;
  static const int MA_DEADLOCK = -27;
  static const int MA_TOO_MANY_LINKS = -28;
  static const int MA_NOT_IMPLEMENTED = -29;
  static const int MA_NO_MESSAGE = -30;
  static const int MA_BAD_MESSAGE = -31;
  static const int MA_NO_DATA_AVAILABLE = -32;
  static const int MA_INVALID_DATA = -33;
  static const int MA_TIMEOUT = -34;
  static const int MA_NO_NETWORK = -35;
  static const int MA_NOT_UNIQUE = -36;
  static const int MA_NOT_SOCKET = -37;
  static const int MA_NO_ADDRESS = -38;
  static const int MA_BAD_PROTOCOL = -39;
  static const int MA_PROTOCOL_UNAVAILABLE = -40;
  static const int MA_PROTOCOL_NOT_SUPPORTED = -41;
  static const int MA_PROTOCOL_FAMILY_NOT_SUPPORTED = -42;
  static const int MA_ADDRESS_FAMILY_NOT_SUPPORTED = -43;
  static const int MA_SOCKET_NOT_SUPPORTED = -44;
  static const int MA_CONNECTION_RESET = -45;
  static const int MA_ALREADY_CONNECTED = -46;
  static const int MA_NOT_CONNECTED = -47;
  static const int MA_CONNECTION_REFUSED = -48;
  static const int MA_NO_HOST = -49;
  static const int MA_IN_PROGRESS = -50;
  static const int MA_CANCELLED = -51;
  static const int MA_MEMORY_ALREADY_MAPPED = -52;

  /// General non-standard errors.
  static const int MA_CRC_MISMATCH = -100;

  /// General miniaudio-specific errors.
  static const int MA_FORMAT_NOT_SUPPORTED = -200;
  static const int MA_DEVICE_TYPE_NOT_SUPPORTED = -201;
  static const int MA_SHARE_MODE_NOT_SUPPORTED = -202;
  static const int MA_NO_BACKEND = -203;
  static const int MA_NO_DEVICE = -204;
  static const int MA_API_NOT_FOUND = -205;
  static const int MA_INVALID_DEVICE_CONFIG = -206;
  static const int MA_LOOP = -207;
  static const int MA_BACKEND_NOT_ENABLED = -208;

  /// State errors.
  static const int MA_DEVICE_NOT_INITIALIZED = -300;
  static const int MA_DEVICE_ALREADY_INITIALIZED = -301;
  static const int MA_DEVICE_NOT_STARTED = -302;
  static const int MA_DEVICE_NOT_STOPPED = -303;

  /// Operation errors.
  static const int MA_FAILED_TO_INIT_BACKEND = -400;
  static const int MA_FAILED_TO_OPEN_BACKEND_DEVICE = -401;
  static const int MA_FAILED_TO_START_BACKEND_DEVICE = -402;
  static const int MA_FAILED_TO_STOP_BACKEND_DEVICE = -403;
}

/// Data Source
typedef ma_data_source = ffi.Void;
typedef Dartma_data_source = void;
typedef ma_uint64 = ffi.UnsignedLongLong;
typedef Dartma_uint64 = int;

abstract class ma_format {
  /// Mainly used for indicating an error, but also used as the default for the output format for decoders.
  static const int ma_format_unknown = 0;
  static const int ma_format_u8 = 1;

  /// Seems to be the most widely supported format.
  static const int ma_format_s16 = 2;

  /// Tightly packed. 3 bytes per sample.
  static const int ma_format_s24 = 3;
  static const int ma_format_s32 = 4;
  static const int ma_format_f32 = 5;
  static const int ma_format_count = 6;
}

typedef ma_uint32 = ffi.UnsignedInt;
typedef Dartma_uint32 = int;
typedef ma_channel = ma_uint8;
typedef ma_uint8 = ffi.UnsignedChar;
typedef Dartma_uint8 = int;
typedef ma_bool32 = ma_uint32;
typedef ma_data_source_get_next_proc
    = ffi.Pointer<ffi.NativeFunction<ma_data_source_get_next_procFunction>>;
typedef ma_data_source_get_next_procFunction = ffi.Pointer<ma_data_source>
    Function(ffi.Pointer<ma_data_source> pDataSource);

/// audio callback function
typedef rta_audio_callback_t
    = ffi.Pointer<ffi.NativeFunction<rta_audio_callback_tFunction>>;
typedef rta_audio_callback_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Float> output, ffi.Int frameCount);
typedef Dartrta_audio_callback_tFunction = void Function(
    ffi.Pointer<ffi.Float> output, int frameCount);

final class rta_audio_device_t extends ffi.Struct {
  @ffi.Int()
  external int id;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> name;

  external ma_device_info info;
}

final class ma_device_info extends ffi.Struct {
  /// Basic info. This is the only information guaranteed to be filled in during device enumeration.
  external ma_device_id id;

  /// +1 for null terminator.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> name;

  @ma_bool32()
  external int isDefault;

  @ma_uint32()
  external int nativeDataFormatCount;

  /// ma_format_count * ma_standard_sample_rate_count * MA_MAX_CHANNELS
  @ffi.Array.multi([64])
  external ffi.Array<UnnamedStruct1> nativeDataFormats;
}

final class ma_device_id extends ffi.Union {
  /// WASAPI uses a wchar_t string for identification.
  @ffi.Array.multi([64])
  external ffi.Array<ma_wchar_win32> wasapi;

  /// DirectSound uses a GUID for identification.
  @ffi.Array.multi([16])
  external ffi.Array<ma_uint8> dsound;

  /// When creating a device, WinMM expects a Win32 UINT_PTR for device identification. In practice it's actually just a UINT.
  @ma_uint32()
  external int winmm;

  /// ALSA uses a name string for identification.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> alsa;

  /// PulseAudio uses a name string for identification.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> pulse;

  /// JACK always uses default devices.
  @ffi.Int()
  external int jack;

  /// Core Audio uses a string for identification.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> coreaudio;

  /// "snd/0", etc.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> sndio;

  /// "/dev/audio", etc.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> audio4;

  /// "dev/dsp0", etc. "dev/dsp" for the default device.
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> oss;

  /// AAudio uses a 32-bit integer for identification.
  @ma_int32()
  external int aaudio;

  /// OpenSL|ES uses a 32-bit unsigned integer for identification.
  @ma_uint32()
  external int opensl;

  /// Web Audio always uses default devices for now, but if this changes it'll be a GUID.
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> webaudio;

  /// The custom backend could be anything. Give them a few options.
  external UnnamedUnion1 custom;

  /// The null backend uses an integer for device IDs.
  @ffi.Int()
  external int nullbackend;
}

typedef ma_wchar_win32 = ffi.WChar;
typedef Dartma_wchar_win32 = int;
typedef ma_int32 = ffi.Int;
typedef Dartma_int32 = int;

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Int()
  external int i;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> s;

  external ffi.Pointer<ffi.Void> p;
}

final class UnnamedStruct1 extends ffi.Struct {
  /// Sample format. If set to ma_format_unknown, all sample formats are supported.
  @ffi.Int32()
  external int format;

  /// If set to 0, all channels are supported.
  @ma_uint32()
  external int channels;

  /// If set to 0, all sample rates are supported.
  @ma_uint32()
  external int sampleRate;

  /// A combination of MA_DATA_FORMAT_FLAG_* flags.
  @ma_uint32()
  external int flags;
}

final class rta_audio_context_config_t extends ffi.Struct {
  @ffi.Int()
  external int channels;

  @ffi.Int()
  external int sampleRate;

  external rta_audio_callback_t dataCallback;
}

final class rta_audio_context_t extends ffi.Struct {
  external ma_device device;

  external rta_audio_callback_datasource_t dataSource;
}

final class ma_device extends ffi.Struct {
  external ffi.Pointer<ma_context> pContext;

  @ffi.Int32()
  external int type;

  @ma_uint32()
  external int sampleRate;

  /// The state of the device is variable and can change at any time on any thread. Must be used atomically.
  external ma_atomic_device_state state;

  /// Set once at initialization time and should not be changed after.
  external ma_device_data_proc onData;

  /// Set once at initialization time and should not be changed after.
  external ma_device_notification_proc onNotification;

  /// DEPRECATED. Use the notification callback instead. Set once at initialization time and should not be changed after.
  external ma_stop_proc onStop;

  /// Application defined data.
  external ffi.Pointer<ffi.Void> pUserData;

  external ma_mutex startStopLock;

  external ma_event wakeupEvent;

  external ma_event startEvent;

  external ma_event stopEvent;

  external ma_thread thread;

  /// This is set by the worker thread after it's finished doing a job.
  @ffi.Int32()
  external int workResult;

  /// When set to true, uninitializing the device will also uninitialize the context. Set to true when NULL is passed into ma_device_init().
  @ma_bool8()
  external int isOwnerOfContext;

  @ma_bool8()
  external int noPreSilencedOutputBuffer;

  @ma_bool8()
  external int noClip;

  @ma_bool8()
  external int noDisableDenormals;

  @ma_bool8()
  external int noFixedSizedCallback;

  /// Linear 0..1. Can be read and written simultaneously by different threads. Must be used atomically.
  external ma_atomic_float masterVolumeFactor;

  /// Intermediary buffer for duplex device on asynchronous backends.
  external ma_duplex_rb duplexRB;

  external UnnamedStruct28 resampling;

  external UnnamedStruct30 playback;

  external UnnamedStruct31 capture;

  external UnnamedUnion10 unnamed;
}

final class ma_context extends ffi.Struct {
  external ma_backend_callbacks callbacks;

  /// DirectSound, ALSA, etc.
  @ffi.Int32()
  external int backend;

  external ffi.Pointer<ma_log> pLog;

  /// Only used if the log is owned by the context. The pLog member will be set to &log in this case.
  external ma_log log;

  @ffi.Int32()
  external int threadPriority;

  @ffi.Size()
  external int threadStackSize;

  external ffi.Pointer<ffi.Void> pUserData;

  external ma_allocation_callbacks allocationCallbacks;

  /// Used to make ma_context_get_devices() thread safe.
  external ma_mutex deviceEnumLock;

  /// Used to make ma_context_get_device_info() thread safe.
  external ma_mutex deviceInfoLock;

  /// Total capacity of pDeviceInfos.
  @ma_uint32()
  external int deviceInfoCapacity;

  @ma_uint32()
  external int playbackDeviceInfoCount;

  @ma_uint32()
  external int captureDeviceInfoCount;

  /// Playback devices first, then capture.
  external ffi.Pointer<ma_device_info> pDeviceInfos;

  external UnnamedUnion3 unnamed;

  external UnnamedUnion5 unnamed1;
}

/// These are the callbacks required to be implemented for a backend. These callbacks are grouped into two parts: context and device. There is one context
/// to many devices. A device is created from a context.
///
/// The general flow goes like this:
///
/// 1) A context is created with `onContextInit()`
/// 1a) Available devices can be enumerated with `onContextEnumerateDevices()` if required.
/// 1b) Detailed information about a device can be queried with `onContextGetDeviceInfo()` if required.
/// 2) A device is created from the context that was created in the first step using `onDeviceInit()`, and optionally a device ID that was
/// selected from device enumeration via `onContextEnumerateDevices()`.
/// 3) A device is started or stopped with `onDeviceStart()` / `onDeviceStop()`
/// 4) Data is delivered to and from the device by the backend. This is always done based on the native format returned by the prior call
/// to `onDeviceInit()`. Conversion between the device's native format and the format requested by the application will be handled by
/// miniaudio internally.
///
/// Initialization of the context is quite simple. You need to do any necessary initialization of internal objects and then output the
/// callbacks defined in this structure.
///
/// Once the context has been initialized you can initialize a device. Before doing so, however, the application may want to know which
/// physical devices are available. This is where `onContextEnumerateDevices()` comes in. This is fairly simple. For each device, fire the
/// given callback with, at a minimum, the basic information filled out in `ma_device_info`. When the callback returns `MA_FALSE`, enumeration
/// needs to stop and the `onContextEnumerateDevices()` function returns with a success code.
///
/// Detailed device information can be retrieved from a device ID using `onContextGetDeviceInfo()`. This takes as input the device type and ID,
/// and on output returns detailed information about the device in `ma_device_info`. The `onContextGetDeviceInfo()` callback must handle the
/// case when the device ID is NULL, in which case information about the default device needs to be retrieved.
///
/// Once the context has been created and the device ID retrieved (if using anything other than the default device), the device can be created.
/// This is a little bit more complicated than initialization of the context due to it's more complicated configuration. When initializing a
/// device, a duplex device may be requested. This means a separate data format needs to be specified for both playback and capture. On input,
/// the data format is set to what the application wants. On output it's set to the native format which should match as closely as possible to
/// the requested format. The conversion between the format requested by the application and the device's native format will be handled
/// internally by miniaudio.
///
/// On input, if the sample format is set to `ma_format_unknown`, the backend is free to use whatever sample format it desires, so long as it's
/// supported by miniaudio. When the channel count is set to 0, the backend should use the device's native channel count. The same applies for
/// sample rate. For the channel map, the default should be used when `ma_channel_map_is_blank()` returns true (all channels set to
/// `MA_CHANNEL_NONE`). On input, the `periodSizeInFrames` or `periodSizeInMilliseconds` option should always be set. The backend should
/// inspect both of these variables. If `periodSizeInFrames` is set, it should take priority, otherwise it needs to be derived from the period
/// size in milliseconds (`periodSizeInMilliseconds`) and the sample rate, keeping in mind that the sample rate may be 0, in which case the
/// sample rate will need to be determined before calculating the period size in frames. On output, all members of the `ma_device_descriptor`
/// object should be set to a valid value, except for `periodSizeInMilliseconds` which is optional (`periodSizeInFrames` *must* be set).
///
/// Starting and stopping of the device is done with `onDeviceStart()` and `onDeviceStop()` and should be self-explanatory. If the backend uses
/// asynchronous reading and writing, `onDeviceStart()` and `onDeviceStop()` should always be implemented.
///
/// The handling of data delivery between the application and the device is the most complicated part of the process. To make this a bit
/// easier, some helper callbacks are available. If the backend uses a blocking read/write style of API, the `onDeviceRead()` and
/// `onDeviceWrite()` callbacks can optionally be implemented. These are blocking and work just like reading and writing from a file. If the
/// backend uses a callback for data delivery, that callback must call `ma_device_handle_backend_data_callback()` from within it's callback.
/// This allows miniaudio to then process any necessary data conversion and then pass it to the miniaudio data callback.
///
/// If the backend requires absolute flexibility with it's data delivery, it can optionally implement the `onDeviceDataLoop()` callback
/// which will allow it to implement the logic that will run on the audio thread. This is much more advanced and is completely optional.
///
/// The audio thread should run data delivery logic in a loop while `ma_device_get_state() == ma_device_state_started` and no errors have been
/// encountered. Do not start or stop the device here. That will be handled from outside the `onDeviceDataLoop()` callback.
///
/// The invocation of the `onDeviceDataLoop()` callback will be handled by miniaudio. When you start the device, miniaudio will fire this
/// callback. When the device is stopped, the `ma_device_get_state() == ma_device_state_started` condition will fail and the loop will be terminated
/// which will then fall through to the part that stops the device. For an example on how to implement the `onDeviceDataLoop()` callback,
/// look at `ma_device_audio_thread__default_read_write()`. Implement the `onDeviceDataLoopWakeup()` callback if you need a mechanism to
/// wake up the audio thread.
///
/// If the backend supports an optimized retrieval of device information from an initialized `ma_device` object, it should implement the
/// `onDeviceGetInfo()` callback. This is optional, in which case it will fall back to `onContextGetDeviceInfo()` which is less efficient.
final class ma_backend_callbacks extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ma_context> pContext,
              ffi.Pointer<ma_context_config> pConfig,
              ffi.Pointer<ma_backend_callbacks> pCallbacks)>> onContextInit;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<ma_context> pContext)>>
      onContextUninit;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ma_context> pContext,
              ma_enum_devices_callback_proc callback,
              ffi.Pointer<ffi.Void> pUserData)>> onContextEnumerateDevices;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ma_context> pContext,
              ffi.Int32 deviceType,
              ffi.Pointer<ma_device_id> pDeviceID,
              ffi.Pointer<ma_device_info> pDeviceInfo)>> onContextGetDeviceInfo;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ma_device> pDevice,
                  ffi.Pointer<ma_device_config> pConfig,
                  ffi.Pointer<ma_device_descriptor> pDescriptorPlayback,
                  ffi.Pointer<ma_device_descriptor> pDescriptorCapture)>>
      onDeviceInit;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<ma_device> pDevice)>>
      onDeviceUninit;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<ma_device> pDevice)>>
      onDeviceStart;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<ma_device> pDevice)>>
      onDeviceStop;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ma_device> pDevice,
              ffi.Pointer<ffi.Void> pFrames,
              ma_uint32 frameCount,
              ffi.Pointer<ma_uint32> pFramesRead)>> onDeviceRead;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ma_device> pDevice,
              ffi.Pointer<ffi.Void> pFrames,
              ma_uint32 frameCount,
              ffi.Pointer<ma_uint32> pFramesWritten)>> onDeviceWrite;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<ma_device> pDevice)>>
      onDeviceDataLoop;

  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<ma_device> pDevice)>>
      onDeviceDataLoopWakeup;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ma_device> pDevice, ffi.Int32 type,
              ffi.Pointer<ma_device_info> pDeviceInfo)>> onDeviceGetInfo;
}

final class ma_context_config extends ffi.Struct {
  external ffi.Pointer<ma_log> pLog;

  @ffi.Int32()
  external int threadPriority;

  @ffi.Size()
  external int threadStackSize;

  external ffi.Pointer<ffi.Void> pUserData;

  external ma_allocation_callbacks allocationCallbacks;

  external UnnamedStruct2 alsa;

  external UnnamedStruct3 pulse;

  external UnnamedStruct4 coreaudio;

  external UnnamedStruct5 jack;

  external ma_backend_callbacks custom;
}

final class ma_log extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ma_log_callback> callbacks;

  @ma_uint32()
  external int callbackCount;

  /// Need to store these persistently because ma_log_postv() might need to allocate a buffer on the heap.
  external ma_allocation_callbacks allocationCallbacks;

  /// For thread safety just to make it easier and safer for the logging implementation.
  external ma_mutex lock;
}

final class ma_log_callback extends ffi.Struct {
  external ma_log_callback_proc onLog;

  external ffi.Pointer<ffi.Void> pUserData;
}

/// The callback for handling log messages.
///
///
/// Parameters
/// ----------
/// pUserData (in)
/// The user data pointer that was passed into ma_log_register_callback().
///
/// logLevel (in)
/// The log level. This can be one of the following:
///
/// +----------------------+
/// | Log Level            |
/// +----------------------+
/// | MA_LOG_LEVEL_DEBUG   |
/// | MA_LOG_LEVEL_INFO    |
/// | MA_LOG_LEVEL_WARNING |
/// | MA_LOG_LEVEL_ERROR   |
/// +----------------------+
///
/// pMessage (in)
/// The log message.
typedef ma_log_callback_proc
    = ffi.Pointer<ffi.NativeFunction<ma_log_callback_procFunction>>;
typedef ma_log_callback_procFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> pUserData,
    ma_uint32 level,
    ffi.Pointer<ffi.Char> pMessage);
typedef Dartma_log_callback_procFunction = void Function(
    ffi.Pointer<ffi.Void> pUserData,
    Dartma_uint32 level,
    ffi.Pointer<ffi.Char> pMessage);

final class ma_allocation_callbacks extends ffi.Struct {
  external ffi.Pointer<ffi.Void> pUserData;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size sz, ffi.Pointer<ffi.Void> pUserData)>> onMalloc;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> p, ffi.Size sz,
              ffi.Pointer<ffi.Void> pUserData)>> onRealloc;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> p, ffi.Pointer<ffi.Void> pUserData)>>
      onFree;
}

typedef ma_mutex = ma_handle;
typedef ma_handle = ffi.Pointer<ffi.Void>;

/// Thread priorities should be ordered such that the default priority of the worker thread is 0.
abstract class ma_thread_priority {
  static const int ma_thread_priority_idle = -5;
  static const int ma_thread_priority_lowest = -4;
  static const int ma_thread_priority_low = -3;
  static const int ma_thread_priority_normal = -2;
  static const int ma_thread_priority_high = -1;
  static const int ma_thread_priority_highest = 0;
  static const int ma_thread_priority_realtime = 1;
  static const int ma_thread_priority_default = 0;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ma_bool32()
  external int useVerboseDeviceEnumeration;
}

final class UnnamedStruct3 extends ffi.Struct {
  external ffi.Pointer<ffi.Char> pApplicationName;

  external ffi.Pointer<ffi.Char> pServerName;

  /// Enables autospawning of the PulseAudio daemon if necessary.
  @ma_bool32()
  external int tryAutoSpawn;
}

final class UnnamedStruct4 extends ffi.Struct {
  @ffi.Int32()
  external int sessionCategory;

  @ma_uint32()
  external int sessionCategoryOptions;

  /// iOS only. When set to true, does not perform an explicit [[AVAudioSession sharedInstace] setActive:true] on initialization.
  @ma_bool32()
  external int noAudioSessionActivate;

  /// iOS only. When set to true, does not perform an explicit [[AVAudioSession sharedInstace] setActive:false] on uninitialization.
  @ma_bool32()
  external int noAudioSessionDeactivate;
}

/// iOS/tvOS/watchOS session categories.
abstract class ma_ios_session_category {
  /// AVAudioSessionCategoryPlayAndRecord.
  static const int ma_ios_session_category_default = 0;

  /// Leave the session category unchanged.
  static const int ma_ios_session_category_none = 1;

  /// AVAudioSessionCategoryAmbient
  static const int ma_ios_session_category_ambient = 2;

  /// AVAudioSessionCategorySoloAmbient
  static const int ma_ios_session_category_solo_ambient = 3;

  /// AVAudioSessionCategoryPlayback
  static const int ma_ios_session_category_playback = 4;

  /// AVAudioSessionCategoryRecord
  static const int ma_ios_session_category_record = 5;

  /// AVAudioSessionCategoryPlayAndRecord
  static const int ma_ios_session_category_play_and_record = 6;

  /// AVAudioSessionCategoryMultiRoute
  static const int ma_ios_session_category_multi_route = 7;
}

final class UnnamedStruct5 extends ffi.Struct {
  external ffi.Pointer<ffi.Char> pClientName;

  @ma_bool32()
  external int tryStartServer;
}

/// The callback for handling device enumeration. This is fired from `ma_context_enumerate_devices()`.
///
///
/// Parameters
/// ----------
/// pContext (in)
/// A pointer to the context performing the enumeration.
///
/// deviceType (in)
/// The type of the device being enumerated. This will always be either `ma_device_type_playback` or `ma_device_type_capture`.
///
/// pInfo (in)
/// A pointer to a `ma_device_info` containing the ID and name of the enumerated device. Note that this will not include detailed information about the device,
/// only basic information (ID and name). The reason for this is that it would otherwise require opening the backend device to probe for the information which
/// is too inefficient.
///
/// pUserData (in)
/// The user data pointer passed into `ma_context_enumerate_devices()`.
typedef ma_enum_devices_callback_proc
    = ffi.Pointer<ffi.NativeFunction<ma_enum_devices_callback_procFunction>>;
typedef ma_enum_devices_callback_procFunction = ma_bool32 Function(
    ffi.Pointer<ma_context> pContext,
    ffi.Int32 deviceType,
    ffi.Pointer<ma_device_info> pInfo,
    ffi.Pointer<ffi.Void> pUserData);
typedef Dartma_enum_devices_callback_procFunction = Dartma_uint32 Function(
    ffi.Pointer<ma_context> pContext,
    int deviceType,
    ffi.Pointer<ma_device_info> pInfo,
    ffi.Pointer<ffi.Void> pUserData);

abstract class ma_device_type {
  static const int ma_device_type_playback = 1;
  static const int ma_device_type_capture = 2;

  /// 3
  static const int ma_device_type_duplex = 3;
  static const int ma_device_type_loopback = 4;
}

final class ma_device_config extends ffi.Struct {
  @ffi.Int32()
  external int deviceType;

  @ma_uint32()
  external int sampleRate;

  @ma_uint32()
  external int periodSizeInFrames;

  @ma_uint32()
  external int periodSizeInMilliseconds;

  @ma_uint32()
  external int periods;

  @ffi.Int32()
  external int performanceProfile;

  /// When set to true, the contents of the output buffer passed into the data callback will be left undefined rather than initialized to silence.
  @ma_bool8()
  external int noPreSilencedOutputBuffer;

  /// When set to true, the contents of the output buffer passed into the data callback will not be clipped after returning. Only applies when the playback sample format is f32.
  @ma_bool8()
  external int noClip;

  /// Do not disable denormals when firing the data callback.
  @ma_bool8()
  external int noDisableDenormals;

  /// Disables strict fixed-sized data callbacks. Setting this to true will result in the period size being treated only as a hint to the backend. This is an optimization for those who don't need fixed sized callbacks.
  @ma_bool8()
  external int noFixedSizedCallback;

  external ma_device_data_proc dataCallback;

  external ma_device_notification_proc notificationCallback;

  external ma_stop_proc stopCallback;

  external ffi.Pointer<ffi.Void> pUserData;

  external ma_resampler_config resampling;

  external UnnamedStruct11 playback;

  external UnnamedStruct12 capture;

  external UnnamedStruct13 wasapi;

  external UnnamedStruct14 alsa;

  external UnnamedStruct15 pulse;

  external UnnamedStruct16 coreaudio;

  external UnnamedStruct17 opensl;

  external UnnamedStruct18 aaudio;
}

abstract class ma_performance_profile {
  static const int ma_performance_profile_low_latency = 0;
  static const int ma_performance_profile_conservative = 1;
}

typedef ma_bool8 = ma_uint8;

/// The callback for processing audio data from the device.
///
/// The data callback is fired by miniaudio whenever the device needs to have more data delivered to a playback device, or when a capture device has some data
/// available. This is called as soon as the backend asks for more data which means it may be called with inconsistent frame counts. You cannot assume the
/// callback will be fired with a consistent frame count.
///
///
/// Parameters
/// ----------
/// pDevice (in)
/// A pointer to the relevant device.
///
/// pOutput (out)
/// A pointer to the output buffer that will receive audio data that will later be played back through the speakers. This will be non-null for a playback or
/// full-duplex device and null for a capture and loopback device.
///
/// pInput (in)
/// A pointer to the buffer containing input data from a recording device. This will be non-null for a capture, full-duplex or loopback device and null for a
/// playback device.
///
/// frameCount (in)
/// The number of PCM frames to process. Note that this will not necessarily be equal to what you requested when you initialized the device. The
/// `periodSizeInFrames` and `periodSizeInMilliseconds` members of the device config are just hints, and are not necessarily exactly what you'll get. You must
/// not assume this will always be the same value each time the callback is fired.
///
///
/// Remarks
/// -------
/// You cannot stop and start the device from inside the callback or else you'll get a deadlock. You must also not uninitialize the device from inside the
/// callback. The following APIs cannot be called from inside the callback:
///
/// ma_device_init()
/// ma_device_init_ex()
/// ma_device_uninit()
/// ma_device_start()
/// ma_device_stop()
///
/// The proper way to stop the device is to call `ma_device_stop()` from a different thread, normally the main application thread.
typedef ma_device_data_proc
    = ffi.Pointer<ffi.NativeFunction<ma_device_data_procFunction>>;
typedef ma_device_data_procFunction = ffi.Void Function(
    ffi.Pointer<ma_device> pDevice,
    ffi.Pointer<ffi.Void> pOutput,
    ffi.Pointer<ffi.Void> pInput,
    ma_uint32 frameCount);
typedef Dartma_device_data_procFunction = void Function(
    ffi.Pointer<ma_device> pDevice,
    ffi.Pointer<ffi.Void> pOutput,
    ffi.Pointer<ffi.Void> pInput,
    Dartma_uint32 frameCount);

/// The notification callback for when the application should be notified of a change to the device.
///
/// This callback is used for notifying the application of changes such as when the device has started,
/// stopped, rerouted or an interruption has occurred. Note that not all backends will post all
/// notification types. For example, some backends will perform automatic stream routing without any
/// kind of notification to the host program which means miniaudio will never know about it and will
/// never be able to fire the rerouted notification. You should keep this in mind when designing your
/// program.
///
/// The stopped notification will *not* get fired when a device is rerouted.
///
///
/// Parameters
/// ----------
/// pNotification (in)
/// A pointer to a structure containing information about the event. Use the `pDevice` member of
/// this object to retrieve the relevant device. The `type` member can be used to discriminate
/// against each of the notification types.
///
///
/// Remarks
/// -------
/// Do not restart or uninitialize the device from the callback.
///
/// Not all notifications will be triggered by all backends, however the started and stopped events
/// should be reliable for all backends. Some backends do not have a good way to detect device
/// stoppages due to unplugging the device which may result in the stopped callback not getting
/// fired. This has been observed with at least one BSD variant.
///
/// The rerouted notification is fired *after* the reroute has occurred. The stopped notification will
/// not* get fired when a device is rerouted. The following backends are known to do automatic stream
/// rerouting, but do not have a way to be notified of the change:
///
/// DirectSound
///
/// The interruption notifications are used on mobile platforms for detecting when audio is interrupted
/// due to things like an incoming phone call. Currently this is only implemented on iOS. None of the
/// Android backends will report this notification.
typedef ma_device_notification_proc
    = ffi.Pointer<ffi.NativeFunction<ma_device_notification_procFunction>>;
typedef ma_device_notification_procFunction = ffi.Void Function(
    ffi.Pointer<ma_device_notification> pNotification);
typedef Dartma_device_notification_procFunction = void Function(
    ffi.Pointer<ma_device_notification> pNotification);

final class ma_device_notification extends ffi.Struct {
  external ffi.Pointer<ma_device> pDevice;

  @ffi.Int32()
  external int type;

  external UnnamedUnion2 data;
}

/// Device notification types.
abstract class ma_device_notification_type {
  static const int ma_device_notification_type_started = 0;
  static const int ma_device_notification_type_stopped = 1;
  static const int ma_device_notification_type_rerouted = 2;
  static const int ma_device_notification_type_interruption_began = 3;
  static const int ma_device_notification_type_interruption_ended = 4;
  static const int ma_device_notification_type_unlocked = 5;
}

final class UnnamedUnion2 extends ffi.Union {
  external UnnamedStruct6 started;

  external UnnamedStruct7 stopped;

  external UnnamedStruct8 rerouted;

  external UnnamedStruct9 interruption;
}

final class UnnamedStruct6 extends ffi.Struct {
  @ffi.Int()
  external int _unused;
}

final class UnnamedStruct7 extends ffi.Struct {
  @ffi.Int()
  external int _unused;
}

final class UnnamedStruct8 extends ffi.Struct {
  @ffi.Int()
  external int _unused;
}

final class UnnamedStruct9 extends ffi.Struct {
  @ffi.Int()
  external int _unused;
}

/// DEPRECATED. Use ma_device_notification_proc instead.
///
/// The callback for when the device has been stopped.
///
/// This will be called when the device is stopped explicitly with `ma_device_stop()` and also called implicitly when the device is stopped through external forces
/// such as being unplugged or an internal error occurring.
///
///
/// Parameters
/// ----------
/// pDevice (in)
/// A pointer to the device that has just stopped.
///
///
/// Remarks
/// -------
/// Do not restart or uninitialize the device from the callback.
typedef ma_stop_proc = ffi.Pointer<ffi.NativeFunction<ma_stop_procFunction>>;
typedef ma_stop_procFunction = ffi.Void Function(
    ffi.Pointer<ma_device> pDevice);
typedef Dartma_stop_procFunction = void Function(
    ffi.Pointer<ma_device> pDevice);

final class ma_resampler_config extends ffi.Struct {
  /// Must be either ma_format_f32 or ma_format_s16.
  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  @ma_uint32()
  external int sampleRateIn;

  @ma_uint32()
  external int sampleRateOut;

  /// When set to ma_resample_algorithm_custom, pBackendVTable will be used.
  @ffi.Int32()
  external int algorithm;

  external ffi.Pointer<ma_resampling_backend_vtable> pBackendVTable;

  external ffi.Pointer<ffi.Void> pBackendUserData;

  external UnnamedStruct10 linear;
}

abstract class ma_resample_algorithm {
  /// Fastest, lowest quality. Optional low-pass filtering. Default.
  static const int ma_resample_algorithm_linear = 0;
  static const int ma_resample_algorithm_custom = 1;
}

final class ma_resampling_backend_vtable extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> pUserData,
              ffi.Pointer<ma_resampler_config> pConfig,
              ffi.Pointer<ffi.Size> pHeapSizeInBytes)>> onGetHeapSize;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void> pUserData,
                  ffi.Pointer<ma_resampler_config> pConfig,
                  ffi.Pointer<ffi.Void> pHeap,
                  ffi.Pointer<ffi.Pointer<ma_resampling_backend>> ppBackend)>>
      onInit;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> pUserData,
                  ffi.Pointer<ma_resampling_backend> pBackend,
                  ffi.Pointer<ma_allocation_callbacks> pAllocationCallbacks)>>
      onUninit;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> pUserData,
              ffi.Pointer<ma_resampling_backend> pBackend,
              ffi.Pointer<ffi.Void> pFramesIn,
              ffi.Pointer<ma_uint64> pFrameCountIn,
              ffi.Pointer<ffi.Void> pFramesOut,
              ffi.Pointer<ma_uint64> pFrameCountOut)>> onProcess;

  /// Optional. Rate changes will be disabled.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Void> pUserData,
              ffi.Pointer<ma_resampling_backend> pBackend,
              ma_uint32 sampleRateIn,
              ma_uint32 sampleRateOut)>> onSetRate;

  /// Optional. Latency will be reported as 0.
  external ffi.Pointer<
      ffi.NativeFunction<
          ma_uint64 Function(ffi.Pointer<ffi.Void> pUserData,
              ffi.Pointer<ma_resampling_backend> pBackend)>> onGetInputLatency;

  /// Optional. Latency will be reported as 0.
  external ffi.Pointer<
      ffi.NativeFunction<
          ma_uint64 Function(ffi.Pointer<ffi.Void> pUserData,
              ffi.Pointer<ma_resampling_backend> pBackend)>> onGetOutputLatency;

  /// Optional. Latency mitigation will be disabled.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void> pUserData,
                  ffi.Pointer<ma_resampling_backend> pBackend,
                  ma_uint64 outputFrameCount,
                  ffi.Pointer<ma_uint64> pInputFrameCount)>>
      onGetRequiredInputFrameCount;

  /// Optional. Latency mitigation will be disabled.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Void> pUserData,
                  ffi.Pointer<ma_resampling_backend> pBackend,
                  ma_uint64 inputFrameCount,
                  ffi.Pointer<ma_uint64> pOutputFrameCount)>>
      onGetExpectedOutputFrameCount;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Void> pUserData,
              ffi.Pointer<ma_resampling_backend> pBackend)>> onReset;
}

typedef ma_resampling_backend = ffi.Void;
typedef Dartma_resampling_backend = void;

final class UnnamedStruct10 extends ffi.Struct {
  @ma_uint32()
  external int lpfOrder;
}

final class UnnamedStruct11 extends ffi.Struct {
  external ffi.Pointer<ma_device_id> pDeviceID;

  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  external ffi.Pointer<ma_channel> pChannelMap;

  @ffi.Int32()
  external int channelMixMode;

  /// When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present.
  @ma_bool32()
  external int calculateLFEFromSpatialChannels;

  @ffi.Int32()
  external int shareMode;
}

abstract class ma_channel_mix_mode {
  /// Simple averaging based on the plane(s) the channel is sitting on.
  static const int ma_channel_mix_mode_rectangular = 0;

  /// Drop excess channels; zeroed out extra channels.
  static const int ma_channel_mix_mode_simple = 1;

  /// Use custom weights specified in ma_channel_converter_config.
  static const int ma_channel_mix_mode_custom_weights = 2;
  static const int ma_channel_mix_mode_default = 0;
}

abstract class ma_share_mode {
  static const int ma_share_mode_shared = 0;
  static const int ma_share_mode_exclusive = 1;
}

final class UnnamedStruct12 extends ffi.Struct {
  external ffi.Pointer<ma_device_id> pDeviceID;

  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  external ffi.Pointer<ma_channel> pChannelMap;

  @ffi.Int32()
  external int channelMixMode;

  /// When an output LFE channel is present, but no input LFE, set to true to set the output LFE to the average of all spatial channels (LR, FR, etc.). Ignored when an input LFE is present.
  @ma_bool32()
  external int calculateLFEFromSpatialChannels;

  @ffi.Int32()
  external int shareMode;
}

final class UnnamedStruct13 extends ffi.Struct {
  /// When configured, uses Avrt APIs to set the thread characteristics.
  @ffi.Int32()
  external int usage;

  /// When set to true, disables the use of AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM.
  @ma_bool8()
  external int noAutoConvertSRC;

  /// When set to true, disables the use of AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY.
  @ma_bool8()
  external int noDefaultQualitySRC;

  /// Disables automatic stream routing.
  @ma_bool8()
  external int noAutoStreamRouting;

  /// Disables WASAPI's hardware offloading feature.
  @ma_bool8()
  external int noHardwareOffloading;

  /// The process ID to include or exclude for loopback mode. Set to 0 to capture audio from all processes. Ignored when an explicit device ID is specified.
  @ma_uint32()
  external int loopbackProcessID;

  /// When set to true, excludes the process specified by loopbackProcessID. By default, the process will be included.
  @ma_bool8()
  external int loopbackProcessExclude;
}

/// WASAPI audio thread priority characteristics.
abstract class ma_wasapi_usage {
  static const int ma_wasapi_usage_default = 0;
  static const int ma_wasapi_usage_games = 1;
  static const int ma_wasapi_usage_pro_audio = 2;
}

final class UnnamedStruct14 extends ffi.Struct {
  /// Disables MMap mode.
  @ma_bool32()
  external int noMMap;

  /// Opens the ALSA device with SND_PCM_NO_AUTO_FORMAT.
  @ma_bool32()
  external int noAutoFormat;

  /// Opens the ALSA device with SND_PCM_NO_AUTO_CHANNELS.
  @ma_bool32()
  external int noAutoChannels;

  /// Opens the ALSA device with SND_PCM_NO_AUTO_RESAMPLE.
  @ma_bool32()
  external int noAutoResample;
}

final class UnnamedStruct15 extends ffi.Struct {
  external ffi.Pointer<ffi.Char> pStreamNamePlayback;

  external ffi.Pointer<ffi.Char> pStreamNameCapture;
}

final class UnnamedStruct16 extends ffi.Struct {
  /// Desktop only. When enabled, allows changing of the sample rate at the operating system level.
  @ma_bool32()
  external int allowNominalSampleRateChange;
}

final class UnnamedStruct17 extends ffi.Struct {
  @ffi.Int32()
  external int streamType;

  @ffi.Int32()
  external int recordingPreset;

  @ma_bool32()
  external int enableCompatibilityWorkarounds;
}

/// OpenSL stream types.
abstract class ma_opensl_stream_type {
  /// Leaves the stream type unset.
  static const int ma_opensl_stream_type_default = 0;

  /// SL_ANDROID_STREAM_VOICE
  static const int ma_opensl_stream_type_voice = 1;

  /// SL_ANDROID_STREAM_SYSTEM
  static const int ma_opensl_stream_type_system = 2;

  /// SL_ANDROID_STREAM_RING
  static const int ma_opensl_stream_type_ring = 3;

  /// SL_ANDROID_STREAM_MEDIA
  static const int ma_opensl_stream_type_media = 4;

  /// SL_ANDROID_STREAM_ALARM
  static const int ma_opensl_stream_type_alarm = 5;

  /// SL_ANDROID_STREAM_NOTIFICATION
  static const int ma_opensl_stream_type_notification = 6;
}

/// OpenSL recording presets.
abstract class ma_opensl_recording_preset {
  /// Leaves the input preset unset.
  static const int ma_opensl_recording_preset_default = 0;

  /// SL_ANDROID_RECORDING_PRESET_GENERIC
  static const int ma_opensl_recording_preset_generic = 1;

  /// SL_ANDROID_RECORDING_PRESET_CAMCORDER
  static const int ma_opensl_recording_preset_camcorder = 2;

  /// SL_ANDROID_RECORDING_PRESET_VOICE_RECOGNITION
  static const int ma_opensl_recording_preset_voice_recognition = 3;

  /// SL_ANDROID_RECORDING_PRESET_VOICE_COMMUNICATION
  static const int ma_opensl_recording_preset_voice_communication = 4;

  /// SL_ANDROID_RECORDING_PRESET_UNPROCESSED
  static const int ma_opensl_recording_preset_voice_unprocessed = 5;
}

final class UnnamedStruct18 extends ffi.Struct {
  @ffi.Int32()
  external int usage;

  @ffi.Int32()
  external int contentType;

  @ffi.Int32()
  external int inputPreset;

  @ffi.Int32()
  external int allowedCapturePolicy;

  @ma_bool32()
  external int noAutoStartAfterReroute;

  @ma_bool32()
  external int enableCompatibilityWorkarounds;
}

/// AAudio usage types.
abstract class ma_aaudio_usage {
  /// Leaves the usage type unset.
  static const int ma_aaudio_usage_default = 0;

  /// AAUDIO_USAGE_MEDIA
  static const int ma_aaudio_usage_media = 1;

  /// AAUDIO_USAGE_VOICE_COMMUNICATION
  static const int ma_aaudio_usage_voice_communication = 2;

  /// AAUDIO_USAGE_VOICE_COMMUNICATION_SIGNALLING
  static const int ma_aaudio_usage_voice_communication_signalling = 3;

  /// AAUDIO_USAGE_ALARM
  static const int ma_aaudio_usage_alarm = 4;

  /// AAUDIO_USAGE_NOTIFICATION
  static const int ma_aaudio_usage_notification = 5;

  /// AAUDIO_USAGE_NOTIFICATION_RINGTONE
  static const int ma_aaudio_usage_notification_ringtone = 6;

  /// AAUDIO_USAGE_NOTIFICATION_EVENT
  static const int ma_aaudio_usage_notification_event = 7;

  /// AAUDIO_USAGE_ASSISTANCE_ACCESSIBILITY
  static const int ma_aaudio_usage_assistance_accessibility = 8;

  /// AAUDIO_USAGE_ASSISTANCE_NAVIGATION_GUIDANCE
  static const int ma_aaudio_usage_assistance_navigation_guidance = 9;

  /// AAUDIO_USAGE_ASSISTANCE_SONIFICATION
  static const int ma_aaudio_usage_assistance_sonification = 10;

  /// AAUDIO_USAGE_GAME
  static const int ma_aaudio_usage_game = 11;

  /// AAUDIO_USAGE_ASSISTANT
  static const int ma_aaudio_usage_assitant = 12;

  /// AAUDIO_SYSTEM_USAGE_EMERGENCY
  static const int ma_aaudio_usage_emergency = 13;

  /// AAUDIO_SYSTEM_USAGE_SAFETY
  static const int ma_aaudio_usage_safety = 14;

  /// AAUDIO_SYSTEM_USAGE_VEHICLE_STATUS
  static const int ma_aaudio_usage_vehicle_status = 15;

  /// AAUDIO_SYSTEM_USAGE_ANNOUNCEMENT
  static const int ma_aaudio_usage_announcement = 16;
}

/// AAudio content types.
abstract class ma_aaudio_content_type {
  /// Leaves the content type unset.
  static const int ma_aaudio_content_type_default = 0;

  /// AAUDIO_CONTENT_TYPE_SPEECH
  static const int ma_aaudio_content_type_speech = 1;

  /// AAUDIO_CONTENT_TYPE_MUSIC
  static const int ma_aaudio_content_type_music = 2;

  /// AAUDIO_CONTENT_TYPE_MOVIE
  static const int ma_aaudio_content_type_movie = 3;

  /// AAUDIO_CONTENT_TYPE_SONIFICATION
  static const int ma_aaudio_content_type_sonification = 4;
}

/// AAudio input presets.
abstract class ma_aaudio_input_preset {
  /// Leaves the input preset unset.
  static const int ma_aaudio_input_preset_default = 0;

  /// AAUDIO_INPUT_PRESET_GENERIC
  static const int ma_aaudio_input_preset_generic = 1;

  /// AAUDIO_INPUT_PRESET_CAMCORDER
  static const int ma_aaudio_input_preset_camcorder = 2;

  /// AAUDIO_INPUT_PRESET_VOICE_RECOGNITION
  static const int ma_aaudio_input_preset_voice_recognition = 3;

  /// AAUDIO_INPUT_PRESET_VOICE_COMMUNICATION
  static const int ma_aaudio_input_preset_voice_communication = 4;

  /// AAUDIO_INPUT_PRESET_UNPROCESSED
  static const int ma_aaudio_input_preset_unprocessed = 5;

  /// AAUDIO_INPUT_PRESET_VOICE_PERFORMANCE
  static const int ma_aaudio_input_preset_voice_performance = 6;
}

abstract class ma_aaudio_allowed_capture_policy {
  /// Leaves the allowed capture policy unset.
  static const int ma_aaudio_allow_capture_default = 0;

  /// AAUDIO_ALLOW_CAPTURE_BY_ALL
  static const int ma_aaudio_allow_capture_by_all = 1;

  /// AAUDIO_ALLOW_CAPTURE_BY_SYSTEM
  static const int ma_aaudio_allow_capture_by_system = 2;

  /// AAUDIO_ALLOW_CAPTURE_BY_NONE
  static const int ma_aaudio_allow_capture_by_none = 3;
}

/// Describes some basic details about a playback or capture device.
final class ma_device_descriptor extends ffi.Struct {
  external ffi.Pointer<ma_device_id> pDeviceID;

  @ffi.Int32()
  external int shareMode;

  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  @ma_uint32()
  external int sampleRate;

  @ffi.Array.multi([254])
  external ffi.Array<ma_channel> channelMap;

  @ma_uint32()
  external int periodSizeInFrames;

  @ma_uint32()
  external int periodSizeInMilliseconds;

  @ma_uint32()
  external int periodCount;
}

/// Backend enums must be in priority order.
abstract class ma_backend {
  static const int ma_backend_wasapi = 0;
  static const int ma_backend_dsound = 1;
  static const int ma_backend_winmm = 2;
  static const int ma_backend_coreaudio = 3;
  static const int ma_backend_sndio = 4;
  static const int ma_backend_audio4 = 5;
  static const int ma_backend_oss = 6;
  static const int ma_backend_pulseaudio = 7;
  static const int ma_backend_alsa = 8;
  static const int ma_backend_jack = 9;
  static const int ma_backend_aaudio = 10;
  static const int ma_backend_opensl = 11;
  static const int ma_backend_webaudio = 12;

  /// <-- Custom backend, with callbacks defined by the context config.
  static const int ma_backend_custom = 13;

  /// <-- Must always be the last item. Lowest priority, and used as the terminator for backend enumeration.
  static const int ma_backend_null = 14;
}

final class UnnamedUnion3 extends ffi.Union {
  external UnnamedStruct19 wasapi;

  external UnnamedStruct23 dsound;

  external UnnamedStruct24 winmm;

  external UnnamedStruct25 jack;

  external UnnamedStruct26 null_backend;
}

final class UnnamedStruct19 extends ffi.Struct {
  external ma_thread commandThread;

  external ma_mutex commandLock;

  external ma_semaphore commandSem;

  @ma_uint32()
  external int commandIndex;

  @ma_uint32()
  external int commandCount;

  @ffi.Array.multi([4])
  external ffi.Array<ma_context_command__wasapi> commands;

  external ma_handle hAvrt;

  external ma_proc AvSetMmThreadCharacteristicsA;

  external ma_proc AvRevertMmThreadcharacteristics;

  external ma_handle hMMDevapi;

  external ma_proc ActivateAudioInterfaceAsync;
}

typedef ma_thread = ma_handle;
typedef ma_semaphore = ma_handle;

/// WASAPI specific structure for some commands which must run on a common thread due to bugs in WASAPI.
final class ma_context_command__wasapi extends ffi.Struct {
  @ffi.Int()
  external int code;

  /// This will be signalled when the event is complete.
  external ffi.Pointer<ma_event> pEvent;

  external UnnamedUnion4 data;
}

typedef ma_event = ma_handle;

final class UnnamedUnion4 extends ffi.Union {
  external UnnamedStruct20 quit;

  external UnnamedStruct21 createAudioClient;

  external UnnamedStruct22 releaseAudioClient;
}

final class UnnamedStruct20 extends ffi.Struct {
  @ffi.Int()
  external int _unused;
}

final class UnnamedStruct21 extends ffi.Struct {
  @ffi.Int32()
  external int deviceType;

  external ffi.Pointer<ffi.Void> pAudioClient;

  external ffi.Pointer<ffi.Pointer<ffi.Void>> ppAudioClientService;

  /// The result from creating the audio client service.
  external ffi.Pointer<ffi.Int32> pResult;
}

final class UnnamedStruct22 extends ffi.Struct {
  external ffi.Pointer<ma_device> pDevice;

  @ffi.Int32()
  external int deviceType;
}

typedef ma_proc = ffi.Pointer<ffi.Void>;

final class UnnamedStruct23 extends ffi.Struct {
  external ma_handle hDSoundDLL;

  external ma_proc DirectSoundCreate;

  external ma_proc DirectSoundEnumerateA;

  external ma_proc DirectSoundCaptureCreate;

  external ma_proc DirectSoundCaptureEnumerateA;
}

final class UnnamedStruct24 extends ffi.Struct {
  external ma_handle hWinMM;

  external ma_proc waveOutGetNumDevs;

  external ma_proc waveOutGetDevCapsA;

  external ma_proc waveOutOpen;

  external ma_proc waveOutClose;

  external ma_proc waveOutPrepareHeader;

  external ma_proc waveOutUnprepareHeader;

  external ma_proc waveOutWrite;

  external ma_proc waveOutReset;

  external ma_proc waveInGetNumDevs;

  external ma_proc waveInGetDevCapsA;

  external ma_proc waveInOpen;

  external ma_proc waveInClose;

  external ma_proc waveInPrepareHeader;

  external ma_proc waveInUnprepareHeader;

  external ma_proc waveInAddBuffer;

  external ma_proc waveInStart;

  external ma_proc waveInReset;
}

final class UnnamedStruct25 extends ffi.Struct {
  external ma_handle jackSO;

  external ma_proc jack_client_open;

  external ma_proc jack_client_close;

  external ma_proc jack_client_name_size;

  external ma_proc jack_set_process_callback;

  external ma_proc jack_set_buffer_size_callback;

  external ma_proc jack_on_shutdown;

  external ma_proc jack_get_sample_rate;

  external ma_proc jack_get_buffer_size;

  external ma_proc jack_get_ports;

  external ma_proc jack_activate;

  external ma_proc jack_deactivate;

  external ma_proc jack_connect;

  external ma_proc jack_port_register;

  external ma_proc jack_port_name;

  external ma_proc jack_port_get_buffer;

  external ma_proc jack_free;

  external ffi.Pointer<ffi.Char> pClientName;

  @ma_bool32()
  external int tryStartServer;
}

final class UnnamedStruct26 extends ffi.Struct {
  @ffi.Int()
  external int _unused;
}

final class UnnamedUnion5 extends ffi.Union {
  external UnnamedStruct27 win32;

  @ffi.Int()
  external int _unused;
}

final class UnnamedStruct27 extends ffi.Struct {
  /// HMODULE
  external ma_handle hOle32DLL;

  external ma_proc CoInitialize;

  external ma_proc CoInitializeEx;

  external ma_proc CoUninitialize;

  external ma_proc CoCreateInstance;

  external ma_proc CoTaskMemFree;

  external ma_proc PropVariantClear;

  external ma_proc StringFromGUID2;

  /// HMODULE
  external ma_handle hUser32DLL;

  external ma_proc GetForegroundWindow;

  external ma_proc GetDesktopWindow;

  /// HMODULE
  external ma_handle hAdvapi32DLL;

  external ma_proc RegOpenKeyExA;

  external ma_proc RegCloseKey;

  external ma_proc RegQueryValueExA;

  /// HRESULT
  @ffi.Long()
  external int CoInitializeResult;
}

final class ma_atomic_device_state extends ffi.Struct {
  @ffi.Int32()
  external int value;
}

abstract class ma_device_state {
  static const int ma_device_state_uninitialized = 0;

  /// The device's default state after initialization.
  static const int ma_device_state_stopped = 1;

  /// The device is started and is requesting and/or delivering audio data.
  static const int ma_device_state_started = 2;

  /// Transitioning from a stopped state to started.
  static const int ma_device_state_starting = 3;

  /// Transitioning from a started state to stopped.
  static const int ma_device_state_stopping = 4;
}

final class ma_atomic_float extends ffi.Struct {
  @ma_float()
  external double value;
}

/// These float types are not used universally by miniaudio. It's to simplify some macro expansion for atomic types.
typedef ma_float = ffi.Float;
typedef Dartma_float = double;

/// The idea of the duplex ring buffer is to act as the intermediary buffer when running two asynchronous devices in a duplex set up. The
/// capture device writes to it, and then a playback device reads from it.
///
/// At the moment this is just a simple naive implementation, but in the future I want to implement some dynamic resampling to seamlessly
/// handle desyncs. Note that the API is work in progress and may change at any time in any version.
///
/// The size of the buffer is based on the capture side since that's what'll be written to the buffer. It is based on the capture period size
/// in frames. The internal sample rate of the capture device is also needed in order to calculate the size.
final class ma_duplex_rb extends ffi.Struct {
  external ma_pcm_rb rb;
}

final class ma_pcm_rb extends ffi.Struct {
  external ma_data_source_base ds;

  external ma_rb rb;

  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  /// Not required for the ring buffer itself, but useful for associating the data with some sample rate, particularly for data sources.
  @ma_uint32()
  external int sampleRate;
}

/// Ring Buffer
final class ma_rb extends ffi.Struct {
  external ffi.Pointer<ffi.Void> pBuffer;

  @ma_uint32()
  external int subbufferSizeInBytes;

  @ma_uint32()
  external int subbufferCount;

  @ma_uint32()
  external int subbufferStrideInBytes;

  /// Most significant bit is the loop flag. Lower 31 bits contains the actual offset in bytes. Must be used atomically.
  @ma_uint32()
  external int encodedReadOffset;

  /// Most significant bit is the loop flag. Lower 31 bits contains the actual offset in bytes. Must be used atomically.
  @ma_uint32()
  external int encodedWriteOffset;

  /// Used to know whether or not miniaudio is responsible for free()-ing the buffer.
  @ma_bool8()
  external int ownsBuffer;

  /// When set, clears the acquired write buffer before returning from ma_rb_acquire_write().
  @ma_bool8()
  external int clearOnWriteAcquire;

  external ma_allocation_callbacks allocationCallbacks;
}

final class UnnamedStruct28 extends ffi.Struct {
  @ffi.Int32()
  external int algorithm;

  external ffi.Pointer<ma_resampling_backend_vtable> pBackendVTable;

  external ffi.Pointer<ffi.Void> pBackendUserData;

  external UnnamedStruct29 linear;
}

final class UnnamedStruct29 extends ffi.Struct {
  @ma_uint32()
  external int lpfOrder;
}

final class UnnamedStruct30 extends ffi.Struct {
  /// Set to NULL if using default ID, otherwise set to the address of "id".
  external ffi.Pointer<ma_device_id> pID;

  /// If using an explicit device, will be set to a copy of the ID used for initialization. Otherwise cleared to 0.
  external ma_device_id id;

  /// Maybe temporary. Likely to be replaced with a query API.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> name;

  /// Set to whatever was passed in when the device was initialized.
  @ffi.Int32()
  external int shareMode;

  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  @ffi.Array.multi([254])
  external ffi.Array<ma_channel> channelMap;

  @ffi.Int32()
  external int internalFormat;

  @ma_uint32()
  external int internalChannels;

  @ma_uint32()
  external int internalSampleRate;

  @ffi.Array.multi([254])
  external ffi.Array<ma_channel> internalChannelMap;

  @ma_uint32()
  external int internalPeriodSizeInFrames;

  @ma_uint32()
  external int internalPeriods;

  @ffi.Int32()
  external int channelMixMode;

  @ma_bool32()
  external int calculateLFEFromSpatialChannels;

  external ma_data_converter converter;

  /// For implementing fixed sized buffer callbacks. Will be null if using variable sized callbacks.
  external ffi.Pointer<ffi.Void> pIntermediaryBuffer;

  @ma_uint32()
  external int intermediaryBufferCap;

  /// How many valid frames are sitting in the intermediary buffer.
  @ma_uint32()
  external int intermediaryBufferLen;

  /// In external format. Can be null.
  external ffi.Pointer<ffi.Void> pInputCache;

  @ma_uint64()
  external int inputCacheCap;

  @ma_uint64()
  external int inputCacheConsumed;

  @ma_uint64()
  external int inputCacheRemaining;
}

final class ma_data_converter extends ffi.Struct {
  @ffi.Int32()
  external int formatIn;

  @ffi.Int32()
  external int formatOut;

  @ma_uint32()
  external int channelsIn;

  @ma_uint32()
  external int channelsOut;

  @ma_uint32()
  external int sampleRateIn;

  @ma_uint32()
  external int sampleRateOut;

  @ffi.Int32()
  external int ditherMode;

  /// The execution path the data converter will follow when processing.
  @ffi.Int32()
  external int executionPath;

  external ma_channel_converter channelConverter;

  external ma_resampler resampler;

  @ma_bool8()
  external int hasPreFormatConversion;

  @ma_bool8()
  external int hasPostFormatConversion;

  @ma_bool8()
  external int hasChannelConverter;

  @ma_bool8()
  external int hasResampler;

  @ma_bool8()
  external int isPassthrough;

  /// Memory management.
  @ma_bool8()
  external int _ownsHeap;

  external ffi.Pointer<ffi.Void> _pHeap;
}

abstract class ma_dither_mode {
  static const int ma_dither_mode_none = 0;
  static const int ma_dither_mode_rectangle = 1;
  static const int ma_dither_mode_triangle = 2;
}

abstract class ma_data_converter_execution_path {
  /// No conversion.
  static const int ma_data_converter_execution_path_passthrough = 0;

  /// Only format conversion.
  static const int ma_data_converter_execution_path_format_only = 1;

  /// Only channel conversion.
  static const int ma_data_converter_execution_path_channels_only = 2;

  /// Only resampling.
  static const int ma_data_converter_execution_path_resample_only = 3;

  /// All conversions, but resample as the first step.
  static const int ma_data_converter_execution_path_resample_first = 4;

  /// All conversions, but channels as the first step.
  static const int ma_data_converter_execution_path_channels_first = 5;
}

final class ma_channel_converter extends ffi.Struct {
  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channelsIn;

  @ma_uint32()
  external int channelsOut;

  @ffi.Int32()
  external int mixingMode;

  @ffi.Int32()
  external int conversionPath;

  external ffi.Pointer<ma_channel> pChannelMapIn;

  external ffi.Pointer<ma_channel> pChannelMapOut;

  /// Indexed by output channel index.
  external ffi.Pointer<ma_uint8> pShuffleTable;

  /// [in][out]
  external UnnamedUnion6 weights;

  /// Memory management.
  external ffi.Pointer<ffi.Void> _pHeap;

  @ma_bool32()
  external int _ownsHeap;
}

/// Channel Conversion
abstract class ma_channel_conversion_path {
  static const int ma_channel_conversion_path_unknown = 0;
  static const int ma_channel_conversion_path_passthrough = 1;

  /// Converting to mono.
  static const int ma_channel_conversion_path_mono_out = 2;

  /// Converting from mono.
  static const int ma_channel_conversion_path_mono_in = 3;

  /// Simple shuffle. Will use this when all channels are present in both input and output channel maps, but just in a different order.
  static const int ma_channel_conversion_path_shuffle = 4;

  /// Blended based on weights.
  static const int ma_channel_conversion_path_weights = 5;
}

final class UnnamedUnion6 extends ffi.Union {
  external ffi.Pointer<ffi.Pointer<ffi.Float>> f32;

  external ffi.Pointer<ffi.Pointer<ma_int32>> s16;
}

final class ma_resampler extends ffi.Struct {
  external ffi.Pointer<ma_resampling_backend> pBackend;

  external ffi.Pointer<ma_resampling_backend_vtable> pBackendVTable;

  external ffi.Pointer<ffi.Void> pBackendUserData;

  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  @ma_uint32()
  external int sampleRateIn;

  @ma_uint32()
  external int sampleRateOut;

  /// State for stock resamplers so we can avoid a malloc. For stock resamplers, pBackend will point here.
  external UnnamedUnion7 state;

  /// Memory management.
  external ffi.Pointer<ffi.Void> _pHeap;

  @ma_bool32()
  external int _ownsHeap;
}

final class UnnamedUnion7 extends ffi.Union {
  external ma_linear_resampler linear;
}

final class ma_linear_resampler extends ffi.Struct {
  external ma_linear_resampler_config config;

  @ma_uint32()
  external int inAdvanceInt;

  @ma_uint32()
  external int inAdvanceFrac;

  @ma_uint32()
  external int inTimeInt;

  @ma_uint32()
  external int inTimeFrac;

  /// The previous input frame.
  external UnnamedUnion8 x0;

  /// The next input frame.
  external UnnamedUnion9 x1;

  external ma_lpf lpf;

  /// Memory management.
  external ffi.Pointer<ffi.Void> _pHeap;

  @ma_bool32()
  external int _ownsHeap;
}

/// Resampling
final class ma_linear_resampler_config extends ffi.Struct {
  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  @ma_uint32()
  external int sampleRateIn;

  @ma_uint32()
  external int sampleRateOut;

  /// The low-pass filter order. Setting this to 0 will disable low-pass filtering.
  @ma_uint32()
  external int lpfOrder;

  /// 0..1. Defaults to 1. 1 = Half the sampling frequency (Nyquist Frequency), 0.5 = Quarter the sampling frequency (half Nyquest Frequency), etc.
  @ffi.Double()
  external double lpfNyquistFactor;
}

final class UnnamedUnion8 extends ffi.Union {
  external ffi.Pointer<ffi.Float> f32;

  external ffi.Pointer<ma_int16> s16;
}

typedef ma_int16 = ffi.Short;
typedef Dartma_int16 = int;

final class UnnamedUnion9 extends ffi.Union {
  external ffi.Pointer<ffi.Float> f32;

  external ffi.Pointer<ma_int16> s16;
}

final class ma_lpf extends ffi.Struct {
  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  @ma_uint32()
  external int sampleRate;

  @ma_uint32()
  external int lpf1Count;

  @ma_uint32()
  external int lpf2Count;

  external ffi.Pointer<ma_lpf1> pLPF1;

  external ffi.Pointer<ma_lpf2> pLPF2;

  /// Memory management.
  external ffi.Pointer<ffi.Void> _pHeap;

  @ma_bool32()
  external int _ownsHeap;
}

final class ma_lpf1 extends ffi.Struct {
  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  external ma_biquad_coefficient a;

  external ffi.Pointer<ma_biquad_coefficient> pR1;

  /// Memory management.
  external ffi.Pointer<ffi.Void> _pHeap;

  @ma_bool32()
  external int _ownsHeap;
}

/// Biquad Filtering
final class ma_biquad_coefficient extends ffi.Union {
  @ffi.Float()
  external double f32;

  @ma_int32()
  external int s32;
}

final class ma_lpf2 extends ffi.Struct {
  /// The second order low-pass filter is implemented as a biquad filter.
  external ma_biquad bq;
}

final class ma_biquad extends ffi.Struct {
  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  external ma_biquad_coefficient b0;

  external ma_biquad_coefficient b1;

  external ma_biquad_coefficient b2;

  external ma_biquad_coefficient a1;

  external ma_biquad_coefficient a2;

  external ffi.Pointer<ma_biquad_coefficient> pR1;

  external ffi.Pointer<ma_biquad_coefficient> pR2;

  /// Memory management.
  external ffi.Pointer<ffi.Void> _pHeap;

  @ma_bool32()
  external int _ownsHeap;
}

final class UnnamedStruct31 extends ffi.Struct {
  /// Set to NULL if using default ID, otherwise set to the address of "id".
  external ffi.Pointer<ma_device_id> pID;

  /// If using an explicit device, will be set to a copy of the ID used for initialization. Otherwise cleared to 0.
  external ma_device_id id;

  /// Maybe temporary. Likely to be replaced with a query API.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> name;

  /// Set to whatever was passed in when the device was initialized.
  @ffi.Int32()
  external int shareMode;

  @ffi.Int32()
  external int format;

  @ma_uint32()
  external int channels;

  @ffi.Array.multi([254])
  external ffi.Array<ma_channel> channelMap;

  @ffi.Int32()
  external int internalFormat;

  @ma_uint32()
  external int internalChannels;

  @ma_uint32()
  external int internalSampleRate;

  @ffi.Array.multi([254])
  external ffi.Array<ma_channel> internalChannelMap;

  @ma_uint32()
  external int internalPeriodSizeInFrames;

  @ma_uint32()
  external int internalPeriods;

  @ffi.Int32()
  external int channelMixMode;

  @ma_bool32()
  external int calculateLFEFromSpatialChannels;

  external ma_data_converter converter;

  /// For implementing fixed sized buffer callbacks. Will be null if using variable sized callbacks.
  external ffi.Pointer<ffi.Void> pIntermediaryBuffer;

  @ma_uint32()
  external int intermediaryBufferCap;

  /// How many valid frames are sitting in the intermediary buffer.
  @ma_uint32()
  external int intermediaryBufferLen;
}

final class UnnamedUnion10 extends ffi.Union {
  external UnnamedStruct32 wasapi;

  external UnnamedStruct33 dsound;

  external UnnamedStruct34 winmm;

  external UnnamedStruct35 jack;

  external UnnamedStruct36 null_device;
}

final class UnnamedStruct32 extends ffi.Struct {
  /// IAudioClient
  external ma_ptr pAudioClientPlayback;

  /// IAudioClient
  external ma_ptr pAudioClientCapture;

  /// IAudioRenderClient
  external ma_ptr pRenderClient;

  /// IAudioCaptureClient
  external ma_ptr pCaptureClient;

  /// Used for IMMNotificationClient notifications. Required for detecting default device changes.
  external ma_ptr pDeviceEnumerator;

  external ma_IMMNotificationClient notificationClient;

  /// Auto reset. Initialized to signaled.
  external ma_handle hEventPlayback;

  /// Auto reset. Initialized to unsignaled.
  external ma_handle hEventCapture;

  /// Value from GetBufferSize(). internalPeriodSizeInFrames is not set to the _actual_ buffer size when low-latency shared mode is being used due to the way the IAudioClient3 API works.
  @ma_uint32()
  external int actualBufferSizeInFramesPlayback;

  @ma_uint32()
  external int actualBufferSizeInFramesCapture;

  @ma_uint32()
  external int originalPeriodSizeInFrames;

  @ma_uint32()
  external int originalPeriodSizeInMilliseconds;

  @ma_uint32()
  external int originalPeriods;

  @ffi.Int32()
  external int originalPerformanceProfile;

  @ma_uint32()
  external int periodSizeInFramesPlayback;

  @ma_uint32()
  external int periodSizeInFramesCapture;

  external ffi.Pointer<ffi.Void> pMappedBufferCapture;

  @ma_uint32()
  external int mappedBufferCaptureCap;

  @ma_uint32()
  external int mappedBufferCaptureLen;

  external ffi.Pointer<ffi.Void> pMappedBufferPlayback;

  @ma_uint32()
  external int mappedBufferPlaybackCap;

  @ma_uint32()
  external int mappedBufferPlaybackLen;

  /// Can be read and written simultaneously across different threads. Must be used atomically, and must be 32-bit.
  external ma_atomic_bool32 isStartedCapture;

  /// Can be read and written simultaneously across different threads. Must be used atomically, and must be 32-bit.
  external ma_atomic_bool32 isStartedPlayback;

  @ma_uint32()
  external int loopbackProcessID;

  @ma_bool8()
  external int loopbackProcessExclude;

  /// When set to true, disables the use of AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM.
  @ma_bool8()
  external int noAutoConvertSRC;

  /// When set to true, disables the use of AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY.
  @ma_bool8()
  external int noDefaultQualitySRC;

  @ma_bool8()
  external int noHardwareOffloading;

  @ma_bool8()
  external int allowCaptureAutoStreamRouting;

  @ma_bool8()
  external int allowPlaybackAutoStreamRouting;

  @ma_bool8()
  external int isDetachedPlayback;

  @ma_bool8()
  external int isDetachedCapture;

  @ffi.Int32()
  external int usage;

  external ffi.Pointer<ffi.Void> hAvrtHandle;

  external ma_mutex rerouteLock;
}

typedef ma_ptr = ffi.Pointer<ffi.Void>;

/// We need a IMMNotificationClient object for WASAPI.
final class ma_IMMNotificationClient extends ffi.Struct {
  external ffi.Pointer<ffi.Void> lpVtbl;

  @ma_uint32()
  external int counter;

  external ffi.Pointer<ma_device> pDevice;
}

final class ma_atomic_bool32 extends ffi.Struct {
  @ma_bool32()
  external int value;
}

final class UnnamedStruct33 extends ffi.Struct {
  /// LPDIRECTSOUND
  external ma_ptr pPlayback;

  /// LPDIRECTSOUNDBUFFER
  external ma_ptr pPlaybackPrimaryBuffer;

  /// LPDIRECTSOUNDBUFFER
  external ma_ptr pPlaybackBuffer;

  /// LPDIRECTSOUNDCAPTURE
  external ma_ptr pCapture;

  /// LPDIRECTSOUNDCAPTUREBUFFER
  external ma_ptr pCaptureBuffer;
}

final class UnnamedStruct34 extends ffi.Struct {
  /// HWAVEOUT
  external ma_handle hDevicePlayback;

  /// HWAVEIN
  external ma_handle hDeviceCapture;

  /// HANDLE
  external ma_handle hEventPlayback;

  /// HANDLE
  external ma_handle hEventCapture;

  @ma_uint32()
  external int fragmentSizeInFrames;

  /// [0,periods). Used as an index into pWAVEHDRPlayback.
  @ma_uint32()
  external int iNextHeaderPlayback;

  /// [0,periods). Used as an index into pWAVEHDRCapture.
  @ma_uint32()
  external int iNextHeaderCapture;

  /// The number of PCM frames consumed in the buffer in pWAVEHEADER[iNextHeader].
  @ma_uint32()
  external int headerFramesConsumedPlayback;

  /// ^^^
  @ma_uint32()
  external int headerFramesConsumedCapture;

  /// One instantiation for each period.
  external ffi.Pointer<ma_uint8> pWAVEHDRPlayback;

  /// One instantiation for each period.
  external ffi.Pointer<ma_uint8> pWAVEHDRCapture;

  external ffi.Pointer<ma_uint8> pIntermediaryBufferPlayback;

  external ffi.Pointer<ma_uint8> pIntermediaryBufferCapture;

  /// Used internally and is used for the heap allocated data for the intermediary buffer and the WAVEHDR structures.
  external ffi.Pointer<ma_uint8> _pHeapData;
}

final class UnnamedStruct35 extends ffi.Struct {
  /// jack_client_t
  external ma_ptr pClient;

  /// jack_port_t
  external ffi.Pointer<ma_ptr> ppPortsPlayback;

  /// jack_port_t
  external ffi.Pointer<ma_ptr> ppPortsCapture;

  /// Typed as a float because JACK is always floating point.
  external ffi.Pointer<ffi.Float> pIntermediaryBufferPlayback;

  external ffi.Pointer<ffi.Float> pIntermediaryBufferCapture;
}

final class UnnamedStruct36 extends ffi.Struct {
  external ma_thread deviceThread;

  external ma_event operationEvent;

  external ma_event operationCompletionEvent;

  external ma_semaphore operationSemaphore;

  @ma_uint32()
  external int operation;

  @ffi.Int32()
  external int operationResult;

  external ma_timer timer;

  @ffi.Double()
  external double priorRunTime;

  @ma_uint32()
  external int currentPeriodFramesRemainingPlayback;

  @ma_uint32()
  external int currentPeriodFramesRemainingCapture;

  @ma_uint64()
  external int lastProcessedFramePlayback;

  @ma_uint64()
  external int lastProcessedFrameCapture;

  /// Read and written by multiple threads. Must be used atomically, and must be 32-bit for compiler compatibility.
  external ma_atomic_bool32 isStarted;
}

final class ma_timer extends ffi.Union {
  @ma_int64()
  external int counter;

  @ffi.Double()
  external double counterD;
}

typedef ma_int64 = ffi.LongLong;
typedef Dartma_int64 = int;
